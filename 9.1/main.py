#!/usr/bin/env python3
"""
main.py

Реализация одномерной квази-одномерной гемодинамической схемы
(параграф 9.1, формула полной характеристической подстановки).

- Характеристическая формула на входе (аналог формулы (1.9.3) в учебнике)
- Включены силы F_e (трение + гравитация) и F_mp (миогенное / потоковое) в усреднённой форме
- Схема предсказатель-корректор с весом sigma (Crank–Nicolson-like)
- Искусственная вязкость для стабилизации
- Численные защиты: минимальные площади, клиппинг сил и скоростей, проверка на NaN/Inf
- Логирование и визуализация (анимация + временные ряды)

Примечание для диплома:
 - формула для граничного u_in реализует идею передачи данных по характеристике из узла x=h в x=0
   (см. рис. 1.9.1 и формулу (1.9.3)): характеристическая часть + вклад средних сил.
 - F_e взят в форме ~ -8πν u / S (аналог терма трения, см. формулу (1.1.9) в учебнике).
 - F_mp в базовой реализации = 0 (оставлено для будущих расширений: миогенные/периферические эффекты).
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# -------------------------
# 1. ФИЗИКА И ЧИСЛЕННЫЕ ПАРАМЕТРРЫ
# -------------------------
L = 1.0               # длина сегмента, м
Nx = 151              # число узлов по x
h = L / (Nx - 1)      # пространственный шаг

rho = 1060.0          # плотность крови, кг/м^3
nu = 0.0005           # кинематическая вязкость (примерное значение), м^2/с
g = 9.81              # ускорение свободного падения, м/с^2
phi = 0.0             # угол наклона (cos phi используется в силе тяжести)

S0 = 1.0e-4           # опорная площадь (м^2)
p0 = 13300.0          # опорное давление (Па)
K = 2e5               # жёсткость сосудистой стенки (Па) — как в учебнике

# Внешнее возбуждение (сердце) на входе:
A = 800.0             # амплитуда колебаний давления, Па
omega = 30.0 * np.pi  # частота возбуждения, рад/с

# Схема предсказатель-корректор
sigma = 0.6           # вес (0.5 — Crank-Nicolson)

# Искусственная вязкость (стабилизация)
alpha = 0.4           # регулируемый коэффициент для a_u = alpha * h * c0

# Временная сетка — уменьшен шаг для устойчивости при включении F_e
c0 = np.sqrt(K / rho)   # ориентировочная скорость волны
tau = 5e-5               # шаг по времени (с) — выбран совместно с остальными ограничениями
Nt = 4000                # число временных шагов

print(f"c0={c0:.2f} м/с, tau={tau:.5e}, h={h:.5e}")

# -------------------------
# 2. ИНИЦИАЛИЗАЦИЯ ПОЛЕЙ
# -------------------------
x = np.linspace(0.0, L, Nx)
t_array = np.arange(0, Nt) * tau

# Начальное состояние: покой
p = np.ones(Nx) * p0
S = S0 * (1.0 + (p - p0) / K)  # линейное уравнение состояния: S = S0*(1 + (p-p0)/K)
u = np.zeros(Nx)

# Численные защиты / лимиты
S_min = 1e-7         # минимальная допустимая площадь (во избежание деления на ноль)
U_max = 10.0         # ограничение скорости, м/с
F_clip = 50.0        # ограничение величины суммарной силы в характеристике
p_limit = 1e6        # предельное давление (защита от нереалистичных значений)

# Искусственная вязкость численно:
a_u_base = alpha * h * c0
a_s_base = a_u_base * 0.1

# -------------------------
# 3. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
# -------------------------
def S_of_p(p_arr):
    """Линейное уравнение состояния (учебник §9.1)."""
    return S0 * (1.0 + (p_arr - p0) / K)

def laplacian(arr, h_local):
    """Простая дискретизация второго производного (центральная), одностороннее на границах."""
    lap = np.zeros_like(arr)
    lap[1:-1] = (arr[2:] - 2.0 * arr[1:-1] + arr[:-2]) / (h_local ** 2)
    lap[0] = (arr[2] - 2.0 * arr[1] + arr[0]) / (h_local ** 2)
    lap[-1] = (arr[-1] - 2.0 * arr[-2] + arr[-3]) / (h_local ** 2)
    return lap

# -------------------------
# 4. ЛОГИРОВАНИЕ / ВИЗУАЛИЗАЦИЯ
# -------------------------
log_interval = 200
frames_to_save = 250
skip = max(1, Nt // frames_to_save)
p_frames = []

history_t = []
history_p0 = []
history_pmid = []
history_pend = []

# -------------------------
# 5. ОСНОВНОЙ ЦИКЛ (с полной характеристикой и силами)
# -------------------------
for n in range(Nt - 1):

    # -------------------------
    # 5.1 Граничное условие на входе по полной характеристической формуле
    #  (аналог формулы (1.9.3) в учебнике).
    #
    #  u_in = u* + 2*sgn(...) * sqrt(...) + (tau/2)*(F_e + F_mp + F_e* + F_mp*)
    #  В коде мы используем усреднение сил и добавляем клиппинг.
    # -------------------------
    p_in = p0 + A * np.sin(omega * t_array[n])   # назначенное внешнее давление на входе
    p_star = p[1]
    S_star = S[1]
    u_star = u[1]

    S_in = S_of_p(p_in)

    # вычисление сил в соседнем узле (звёздочка) и в "входном" состоянии
    # F_e — внешние силы (трение + гравитация)
    Fe_star = -8.0 * np.pi * nu * u_star / max(S_star, S_min) + g * np.cos(phi)
    Fmp_star = 0.0   # пока без миогенного члена; можно расширить в будущих версиях

    # оценка силы в "входном" состоянии возьмём по u_star (как аппроксимация ближайшего значения)
    Fe_in = -8.0 * np.pi * nu * u_star / max(S_star, S_min) + g * np.cos(phi)
    Fmp_in = 0.0

    # характеристическая часть (корень)
    sqrt_Sin = np.sqrt(max(S_in, S_min))
    sqrt_Ss = np.sqrt(max(S_star, S_min))
    num = (p_in - p_star) * (sqrt_Sin - sqrt_Ss)
    den = rho * (sqrt_Sin + sqrt_Ss) + 1e-12
    # может быть отрицательным внутри, поэтому берём модуль и сохраняем знак отдельно
    term_val = 0.0
    if den != 0.0:
        term_val = np.sqrt(max(abs(num / den), 0.0))

    sg = np.sign(S_in - S_star) if S_in != S_star else 1.0

    # средняя сила (звёздочная + текущая) — затем клиппируем её
    F_avg = 0.5 * (Fe_star + Fe_in + Fmp_star + Fmp_in)
    F_avg = np.clip(F_avg, -F_clip, F_clip)

    # итоговая скорость на входе — формула (1.9.3)-подобная
    u_in = u_star + 2.0 * sg * term_val + tau * F_avg
    u_in = np.clip(u_in, -U_max, U_max)

    # задаём граничные значения
    p[0] = p_in
    S[0] = S_in
    u[0] = u_in

    # -------------------------
    # 5.2 Граничное условие на выходе
    #  Для простоты (как в учебнике для открытого конца) - свободный выход:
    #  p[-1] = p[-2], u[-1] = u[-2]
    #  (в дальнейшем можно заменить на характеристическое условие выхода или Windkessel)
    # -------------------------
    p[-1] = p[-2]
    u[-1] = u[-2]
    S[-1] = S[-2]

    # -------------------------
    # 5.3 Вычисление пространственных производных
    # -------------------------
    # центральные производные внутри, односторонние на границах
    dSdx = np.zeros_like(S)
    dudx = np.zeros_like(u)
    dpdx = np.zeros_like(p)

    dSdx[1:-1] = (S[2:] - S[:-2]) / (2.0 * h)
    dudx[1:-1] = (u[2:] - u[:-2]) / (2.0 * h)
    dpdx[1:-1] = (p[2:] - p[:-2]) / (2.0 * h)

    # границы — односторонние
    dSdx[0] = (S[1] - S[0]) / h
    dudx[0] = (u[1] - u[0]) / h
    dpdx[0] = (p[1] - p[0]) / h

    dSdx[-1] = (S[-1] - S[-2]) / h
    dudx[-1] = (u[-1] - u[-2]) / h
    dpdx[-1] = (p[-1] - p[-2]) / h

    # -------------------------
    # 5.4 Лапласианы (искусственная вязкость)
    # -------------------------
    a_u = a_u_base
    a_s = a_s_base
    lap_u = laplacian(u, h)
    lap_s = laplacian(S, h)

    # -------------------------
    # 5.5 Правая часть (старый слой)
    #  уравнения в форме:
    #   dS/dt = -(u dS/dx + S du/dx) + a_s * lap_s
    #   du/dt = -(u du/dx + (1/rho) dp/dx + friction - g cos phi) + a_u * lap_u
    # -------------------------
    S_safe = np.maximum(S, S_min)
    F_S = -(u * dSdx + S * dudx) + a_s * lap_s
    F_u = -(u * dudx + (1.0 / rho) * dpdx + (8.0 * np.pi * nu * u) / S_safe - g * np.cos(phi)) + a_u * lap_u

    # -------------------------
    # 5.6 Предсказатель (явная часть)
    # -------------------------
    S_pred = np.maximum(S + tau * F_S, S_min)
    u_pred = np.nan_to_num(u + tau * F_u)
    p_pred = p0 + K * (S_pred / S0 - 1.0)

    # -------------------------
    # 5.7 Производные и лапласианы для предсказанного слоя
    # -------------------------
    dSdx_new = np.zeros_like(S_pred)
    dudx_new = np.zeros_like(u_pred)
    dpdx_new = np.zeros_like(p_pred)

    dSdx_new[1:-1] = (S_pred[2:] - S_pred[:-2]) / (2.0 * h)
    dudx_new[1:-1] = (u_pred[2:] - u_pred[:-2]) / (2.0 * h)
    dpdx_new[1:-1] = (p_pred[2:] - p_pred[:-2]) / (2.0 * h)
    dSdx_new[0] = (S_pred[1] - S_pred[0]) / h
    dudx_new[0] = (u_pred[1] - u_pred[0]) / h
    dpdx_new[0] = (p_pred[1] - p_pred[0]) / h
    dSdx_new[-1] = (S_pred[-1] - S_pred[-2]) / h
    dudx_new[-1] = (u_pred[-1] - u_pred[-2]) / h
    dpdx_new[-1] = (p_pred[-1] - p_pred[-2]) / h

    lap_u_new = laplacian(u_pred, h)
    lap_s_new = laplacian(S_pred, h)

    # -------------------------
    # 5.8 Новая правая часть (корректор)
    # -------------------------
    S_pred_safe = np.maximum(S_pred, S_min)
    F_S_new = -(u_pred * dSdx_new + S_pred * dudx_new) + a_s * lap_s_new
    F_u_new = -(u_pred * dudx_new + (1.0 / rho) * dpdx_new +
                (8.0 * np.pi * nu * u_pred) / S_pred_safe - g * np.cos(phi)) + a_u * lap_u_new

    # -------------------------
    # 5.9 Итоговая σ-схема (предсказатель-корректор)
    # -------------------------
    S_new = np.maximum(S + tau * ((1.0 - sigma) * F_S + sigma * F_S_new), S_min)
    u_new = np.nan_to_num(u + tau * ((1.0 - sigma) * F_u + sigma * F_u_new))
    p_new = np.nan_to_num(p0 + K * (S_new / S0 - 1.0))

    # -------------------------
    # 5.10 Обновление полей и проверки
    # -------------------------
    # защита от нереалистичных значений
    u_new = np.clip(u_new, -U_max, U_max)
    p_new = np.clip(p_new, -p_limit, p_limit)
    S_new = np.clip(S_new, S_min, None)

    S, u, p = S_new, u_new, p_new

    # проверка NaN/Inf — аварийная остановка
    if not np.all(np.isfinite(p)) or not np.all(np.isfinite(u)):
        print(f"NaN/Inf detected at step {n}, stopping.")
        break

    # -------------------------
    # 5.11 Логирование и сбор кадров
    # -------------------------
    if n % log_interval == 0:
        print(f"[t={n*tau:.4f}s] p0={p[0]:.1f} Pa, p_mid={p[Nx//2]:.1f} Pa, p_end={p[-1]:.1f} Pa")

    if n % skip == 0:
        p_frames.append(p.copy())

    history_t.append(n * tau)
    history_p0.append(p[0])
    history_pmid.append(p[Nx // 2])
    history_pend.append(p[-1])

# -------------------------
# 6. ВИЗУАЛИЗАЦИЯ: АНИМАЦИЯ ДАВЛЕНИЯ + ВРЕМЕННЫЕ РЯДЫ
# -------------------------
# Анимация профиля давления вдоль сосуда
if len(p_frames) == 0:
    p_frames.append(p.copy())

fig, ax = plt.subplots(figsize=(9, 4))
line, = ax.plot(x, p_frames[0], 'b-', lw=2)
ax.set_xlim(0.0, L)
p_all = np.concatenate(p_frames)
ax.set_ylim(np.min(p_all) - 200.0, np.max(p_all) + 200.0)
ax.set_xlabel("x, м")
ax.set_ylabel("p, Па")
ax.grid(True)

def update(frame):
    line.set_ydata(p_frames[frame])
    ax.set_title(f"t = {frame * skip * tau:.4f} с")
    return (line,)

ani = FuncAnimation(fig, update, frames=len(p_frames), blit=True, interval=30)
plt.show()

# Временные ряды давления в трёх точках: вход, середина, выход
plt.figure(figsize=(9, 4))
plt.plot(history_t, history_p0, label='x=0 (вход)')
plt.plot(history_t, history_pmid, label=f'x={L/2:.2f} (середина)')
plt.plot(history_t, history_pend, label=f'x={L:.2f} (выход)')
plt.xlabel("t, с")
plt.ylabel("p, Па")
plt.title("Временные ряды давления в трёх точках")
plt.legend()
plt.grid(True)
plt.show()

# -------------------------
# 7. КОММЕНТАРИИ ДЛЯ ДИПЛОМА (коротко)
# -------------------------
# - В коде реализована формула (1.9.3) в виде u_in = u* + характеристическая часть + tau * средняя сила.
# - Силы F_e введены в форме трения ~ -8πν u / S (с добавлением гравитации).
# - Для численной устойчивости добавлены: искусственная вязкость (a_u, a_s), минимальная площадь S_min,
#   клиппинг сил (F_clip) и ограничение скоростей (U_max).
# - Выходной узел пока выполнен как свободный (p[-1]=p[-2]) — это соответствует открытому концу,
#   и в учебнике часто используется для иллюстраций в §9.1. Для более реалистичных сосудистых моделей
#   следует ввести модели периферического сопротивления (Windkessel RCR / R) — это можно сделать
#   как расширение проекта.
#
# В случае необходимости подготовлю отдельную версию с:
#  - детальной Windkessel-граничной моделью на выходе,
#  - усреднением F_e по ячейке и тонкой балансировкой единиц,
#  - автоматическим подбором tau/alpha/F_clip.
